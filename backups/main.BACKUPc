//gcc -g main.c -o main `sdl2-config --cflags --libs` -lm
//valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./main
#include <stdio.h>
#include <SDL2/SDL.h>
#include <math.h>

#define WIDTH 1200
#define HEIGHT 900
#define WHITE 0xffffffff
#define BLACK 0x00000000

struct Circle {
    double x, y;
    int r, m;
    double xv, yv, xf, yf;
};

struct Circle createCircle(double x, double y, int r, int m, double xv, double yv) {
    return (struct Circle) {x, y, r, m, xv, yv, 0.0f, 0.0f};
}

void FillCircle(SDL_Surface* surface, struct Circle c, Uint32 color) {
    int x, y, rx, ry, d;
    rx = (int)c.x;
    ry = (int)c.y;
    x = 0;
    y = c.r;
    d = 1 - c.r;

    while (x <= y) {
        // Modified Bresenham's Circle Algorithm
        SDL_FillRect(surface, &(SDL_Rect) {rx - x, ry + y, 2 * x + 1, 1}, color);
        SDL_FillRect(surface, &(SDL_Rect) {rx - x, ry - y, 2 * x + 1, 1}, color);
        SDL_FillRect(surface, &(SDL_Rect) {rx - y, ry + x, 2 * y + 1, 1}, color);
        SDL_FillRect(surface, &(SDL_Rect) {rx - y, ry - x, 2 * y + 1, 1}, color);
        x++;
        if (d < 0) {
            d += 2 * x + 1;
        } 
        else {
            y--;
            d += 2 * (x - y) + 1;
        }
    }
}

void applyObjectVelocity(struct Circle *c) {
    c->x += c->xv;
    c->y += c->yv;
}

void applyObjectGravity(struct Circle *c) {
    c->xv += c->xf/c->m;
    c->yv += c->yf/c->m;
}

void computeGravity(struct Circle *c1, struct Circle *c2) {
    int g;
    double xd, yd, d2, f, xf, yf, a;

    g = 30;
    xd = abs(c1->x - c2->x);
    yd = abs(c1->y - c2->y);
    d2 = xd*xd + yd*yd;
    if (d2 == 0) {
        d2 = 1;
    }
    f = ((double)c1->m * c2->m) / d2;

    if (xd == 0) {
        xf = 0;
        yf = f / g;
    }
    else if (yd == 0) {
        xf = f / g;
        yf = 0;
    }
    else {
        a = atan(yd/xd);
        xf = cos(a) * f / g;
        yf = sin(a) * f / g;
    }

    if (c1->x > c2->x) {
        c1->xf -= xf;
        c2->xf += xf;
    }
    else {
        c1->xf += xf;
        c2->xf -= xf;
    }

    if (c1->y > c2->y) {
        c1->yf -= yf;
        c2->yf += yf;
    }
    else {
        c1->yf += yf;
        c2->yf -= yf;
    }
}


int main() {

    SDL_Init(SDL_INIT_VIDEO);
    SDL_Window *window = SDL_CreateWindow("Gravity", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, WIDTH, HEIGHT, 0);
    SDL_Surface* surface = SDL_GetWindowSurface(window);
    int n = 3;

    struct Circle *circles = malloc(n * sizeof(struct Circle));
    if (circles == NULL) {
        printf("Memory allocation failed");
        return 1;
    }
    memset(circles, 0, n * sizeof(struct Circle));

    circles[0] = createCircle(600, 450, 10, 100000, 0, 0);
    circles[1] = createCircle(400, 700, 5, 100, 2, 0);
    circles[2] = createCircle(700, 100, 5, 100, -2, 0);

    int sim_run = 1;
    SDL_Event event;
    while (sim_run) {
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) {
                sim_run = 0;
            }
        }

        SDL_FillRect(surface, &(SDL_Rect) {0, 0, WIDTH, HEIGHT}, BLACK); 

        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                computeGravity(circles + i, circles + j);
            }
            applyObjectGravity(circles + i);
            applyObjectVelocity(circles + i);
            circles[i].xf = circles[i].yf = 0;
            FillCircle(surface, circles[i], WHITE);
        }

        SDL_UpdateWindowSurface(window);
        SDL_Delay(10);
    }

    free(circles);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
